<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Node.js Performance Optimization Case Study - Node Interactive</title>

    <meta name="description" content="Node.js Performance Optimization Case Study - Node Interactive">
    <meta name="author" content="Bryce B. Baril">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-markdown>
![title slide](img/title_slide.png)
        </section>

        <section data-markdown>
          ## ğŸš€ Performance ğŸš€

          With Node.js we have two key performance targets:
          * Task Completion (User-experience)
          * Throughput (Scale)
        </section>

        <section data-markdown>
          ## ğŸ— Task Completion ğŸ—

          "Work is done in a timely manner."
        </section>

        <section data-markdown>
          ## ğŸ— Task Completion ğŸ—

          With Node.js's event model, these are generally* asynchronous (IO-related) tasks.
        </section>

        <section data-markdown>
          ## ğŸ— Task Completion ğŸ—

          Key metric:

          `task_end - task_start`
        </section>

        <section data-markdown>
          ## ğŸ­ Throughput ğŸ­

          "Work isn't blocking other work."
        </section>

        <section data-markdown>
          ## ğŸ­ Throughput ğŸ­

          Blocking (synchronous) time is generally JavaScript execution or garbage collection.
        </section>

        <section data-markdown>
          ## ğŸ­ Throughput ğŸ­

          Key metric:

          requests-per-second
        </section>

        <section data-markdown>
          ## ğŸ­ Throughput ğŸ­

          **IMPORTANT**:
          Blocking operations can cause cascading blockage resulting in significant task completion delays.
        </section>


        <section data-markdown>
          ## ğŸ–¼ Glitching .gif Images ğŸ–¼
          ### Case Study

          * [readimage](http://npm.im/readimage) reads gif/png/jpg and converts to a common format
          * [glitcher](http://npm.im/glitcher) various image glitches and manpiulations
          * [writegif](http://npm.im/writegif) write that common format to an animated gif
        </section>

        <section>
          <h2> ğŸ“ Workflow ğŸ“ </h2>
          <ol start=0>
            <li>â” Is it fast enough?</li>
            <li>ğŸ” Identify the nature of the problem. (ğŸ— vs ğŸ­)</li>
            <li>ğŸ”¬ Select tools based on the problem.</li>
            <li>ğŸ“ Measure.</li>
            <li>ğŸ“ Identify the location of the problem.</li>
            <li>ğŸ‘“ Make the slower parts faster.</li>
            <li>ğŸ“ Measure again.</li>
            <li>ğŸ” Go back to step 0.</li>
          </ol>
        </section>

        <section data-markdown>
          ## ğŸš¨ WARNING ğŸš¨

          Do **NOT** skip straight to step 5. Randomly applied V8 compiler tricks are unlikely to have a significant impact.
        </section>

        <section data-markdown>
          ## â” 0. Is it fast enough? â”

          The logs show some images take well over a second to manipulate with the manipulation `replaceBackground`, and this is a blocking operation.
        </section>

        <section data-markdown>
          ## ğŸ” 1. Identify the nature of the problem ğŸ”

          Based on logs and the code, I have identified the bulk of the time is the image manipulation. It's not doing any network calls or other asynchronous work.
        </section>

        <section data-markdown>
          ## ğŸ™‹ What if it was async? ğŸ™‹

          * ğŸ›  Tools
            * Logging
            * APM (NewRelic, Dynatrace, etc.)
          * ğŸ’ª Solutions
            * Caching
            * Query optimization
            * etc.

          (out of scope for this presentation)
          Note:
            These are usually infrequent and slow enough you can always log. This is essentially what APM vendors do for you automatically.
        </section>

        <section data-markdown>
          ## ğŸ’» Our test harness ğŸ’»
          ```js
          var THRESHOLD = 40
          var image = /* read file, call readimage */
          function fillBlack(frame) {
            return frame.fill(0)
          }
          replaceBackground(image.frames, fillBlack, THRESHOLD)
          /* call writegif on image, write to file */
          ```
          Note:
          replaceBackground calculates the median frame by comparing every pixel in every frame, then for each frame calculates the difference from that background frame
        </section>

        <section data-markdown>
          ## â³ Before â³
          ![Hotline Bling](img/bling2.gif)
        </section>

        <section data-markdown>
          ## âŒ› After âŒ›
          ![Hotline Bling Manipulated](img/median_bling.gif)
        </section>

        <section data-markdown>
          ## ğŸ”¬ 2. Select tools ğŸ”¬

          For the purpose of this talk, we're going to look at:
          * /usr/bin/time
          * linux `prof` tool
          * v8-profiler
          * IRHydra2
        </section>

        <section data-markdown>
          ## ğŸ›  Tool Categories ğŸ› 

          * How slow is it?
          * Where is the slowness at?
          * Why is it slow?
        </section>

        <section data-markdown>
          ## ğŸ›  How slow is it? ğŸ› 
          * `/usr/bin/time`
          * Benchmark tools (ab, siege, etc.)
        </section>

        <section data-markdown>
          ## ğŸ›  Where is the slowness at? ğŸ› 
          * Kernel tools (perf, dtrace, etc.)
          * V8 Instrumentation (v8-profiler, [NSolid](http://downloads.nodesource.com))
        </section>

        <section data-markdown>
          ## ğŸ“ 3. Measure ğŸ“

          With our selected poor-performing image, we'll use `/usr/bin/time` to measure a baseline:

    $ \time node harness.js ~/Downloads/bling2.gif
    8.67user 0.06system 0:08.71elapsed 100%CPU (0avgtext+0avgdata 181988maxresident)k
    0inputs+752outputs (0major+41833minor)pagefaults 0swaps
        </section>

        <section data-markdown>
          ## ğŸ“ 4. Identify the location ğŸ“
        </section>

        <section data-markdown>
          ## ğŸ›  Using `perf` ğŸ› 

          * The `perf` tool on Linux is a kernel-level CPU profiling tool
          * Captures full stack, C++ & JS execution
          * Follow [these instructions](https://gist.github.com/trevnorris/9616784)

          (They are not up-to-date but the steps are all right)
        </section>

        <section data-markdown>
## ğŸ”¥ How to read a flamegraph ğŸ”¥

* X axis is % of total time
* Y axis is stack depth
* Look for:
  * plateaus
  * fat pyramids
        </section>

        <section data-markdown>
## ğŸ”¥ Perf Flamegraph ğŸ”¥
[![flamegraph from perf tool](img/median-flame.svg)](img/median-flame.svg)
        </section>

        <section data-markdown>
## ğŸ›  v8-profiler ğŸ› 

* See [v8-profiler README](http://npm.im/v8-profiler)
* Uses V8-provided instrumentation hooks
* Profiles JS only
* View by loading into Chrome Dev Tools
        </section>

        <section data-markdown>
## ğŸ“ˆ v8-profiler results ğŸ“ˆ

![v8-profiler results](img/median-cdt.png)
        </section>

        <section data-markdown>
          ## ğŸ’¢ Focus on avg() ğŸ’¢

          The `avg()` function averages every frame to make a simulated background frame.

          Both `perf` and `v8-profiler` indicate we're spending the bulk of the time there.
        </section>

        <section data-markdown>
          ## ğŸ›  Why is it slow? ğŸ› 

          If the problem is slow JavaScript execution:

          * Optimizing compiler output (IRHydra, --prof, --trace-deopt)
          * Code review
          * Static analysis?
        </section>

        <section data-markdown>
## ğŸ™‹ What if it was garbage collection? ğŸ™‹

* ğŸ›  Tools
  * heap snapshots
  * post-mortem analysis (mdb, lldb, etc.)
* ğŸ’ª Solutions
  * fix errant closures
  * hold less data/parts of objects vs whole objects
  * code/static analysis
  * etc.

(out of scope for this presentation)
        </section>

        <section data-markdown>
          ## ğŸ‘“ 5. Make the slower parts faster ğŸ‘“
        </section>


        <section data-markdown>
## ğŸ’© Reasons for Poor Performance ğŸ’©

* Wrong tool for the job
* Doing unnecessary things
* Poor algorithm choice
* Not cooperating with the runtime

Note:
* Node isn't great at everything: ssl termination, use nginx
* don't create functions in loops, avoid Promises
* decrease instruction count
* optimizing compiler makes assumptions, work with it, avoid invalidating assumptions
        </section>

        <section data-markdown>
          ## ğŸš‚ V8 Compiler Output ğŸš‚

          * Lots of tips out there on how to optimize your code for V8.
          * Nothing beats V8 telling you what it didn't like.
          * My favorite tool: [IRHydra2](http://mrale.ph/irhydra/2/)
            * Follow the instructions on that page
            * Load them into IRHydra2 (it's a web app)
        </section>

        <section data-markdown>
## ğŸŒ¡ IRHydra Results ğŸŒ¡
(Load the two files in assets/irhydra into IRHydra to explore)
![IRHydra Result preview](img/median-hydra.png)
        </section>

        <section data-markdown>
## ğŸ” Analysis ğŸ”

* the `avg` function had an eager deoptimization
* ... but it was the inlined Buffer constructor in node core!
* (So I filed a [PR against node](https://github.com/nodejs/node/pull/4158))
* otherwise nothing too interesting Â¯\\\_(ãƒ„)_/Â¯
        </section>

        <section data-markdown>
## ğŸ“ Code Analysis ğŸ“

`avg()` calls `medianPixel()`

The algorithm to calculate `median` requires a sort
        </section>

        <section data-markdown>
## âš– Some Math âš–

Our image is 800 x 450 pixels with 51 frames

    800 * 450 = 360000 pixels per frame

So 360000 51 pixel `sortPixels` calls. ğŸ˜¨
        </section>

        <section data-markdown>
          ## ğŸ“Š Median Frame ğŸ“Š
          ![Median Frame](img/median_frame.gif)
        </section>

        <section data-markdown>
## ğŸ”” Mean ğŸ””

Calculating `mean` doesn't require a sort. Maybe it will work?
        </section>

        <section data-markdown>
          ## ğŸ”” Mean Frame ğŸ””
          ![Mean Frame](img/mean_frame.gif)
        </section>

        <section data-markdown>
          ## âŒ› After 2 âŒ›
          ![Mean Frame](img/mean_bling.gif)
        </section>

        <section data-markdown>
## ğŸ“ 6. Measure again ğŸ“

    $ \time node harness.js ~/Downloads/bling2.gif
    3.40user 0.04system 0:03.43elapsed 100%CPU (0avgtext+0avgdata 182048maxresident)k
    0inputs+704outputs (0major+44011minor)pagefaults 0swaps

8.67 seconds to 3.40 seconds!
        </section>

        <section data-markdown>
## ğŸ”¥ Perf Flamegraph (Mean) ğŸ”¥
[![flamegraph from perf tool using mean](img/mean-flame.svg)](img/mean-flame.svg)
        </section>

        <section data-markdown>
## ğŸ“‰ v8-profiler results ğŸ“‰

![v8-profiler results using mean](img/mean-cdt.png)
        </section>

        <section data-markdown>
## ğŸ” 7. Go back to step 0 ğŸ”

* Fix `copy`: remove call to it?
* Reduce instruction count
* Even better algorithms?
* Optimize `inxsearch` function?
        </section>

        <section data-markdown>
## ğŸ“  Let's remove the call to Buffer::Copy ğŸ“ 

    $ \time node harness.js ~/Downloads/bling2.gif
    2.21user 0.06system 0:02.28elapsed 99%CPU (0avgtext+0avgdata 183944maxresident)k
    10584inputs+704outputs (0major+43860minor)pagefaults 0swaps

Another second saved!

        </section>

        <section data-markdown data-background="img/cpu-profile-nsolid-flamegraph.png">
## ğŸ’– Check out NSolid! ğŸ’–

Capture flamegraphs of a production process with the click of a button!

Bryce B. Baril - [http://brycebaril.com](http://brycebaril.com)

Twitter: [@brycebaril](http://twitter.com/brycebaril)
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
